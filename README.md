# 方糖猫 硬件 后端实现

Coze AI  <-> 树莓派 <-> Arduino


## 1. 系统架构概述

本系统实现了**低功耗嵌入式硬件（Arduino）**与**高性能AI云端服务（Coze）**之间的安全、高效数据交互，支持复杂会话、AI问答、消息转发与语音等功能。

**核心组成与目标如下：**

- **Arduino侧（嵌入式端）**：负责本地传感、用户输入采集、消息组装与串口数据收发，封装指令协议。
- **上位机（Python服务）**：通过`cubeCom` C++扩展库管理串口，解析和处理消息，维护消息队列与状态映射，负责与Coze API交互，实现AI对话、消息管理等。
- **cubeCom上位机服务（C++/pybind11/Python）**：高效处理串口读写、消息分发、队列管理、AI服务适配、数据同步与并发处理。

- **消息协议**：自定义高鲁棒性串口通讯协议（帧头、长度、校验），确保嵌入式与主机的可靠交互。
- **消息队列与同步机制**：设计高效的**循环队列**和线程安全同步，支持多线程消息收发，异步API调用，提升整体吞吐与响应能力。
- **AI服务接口（Coze）**：实现与Coze云服务的交互，映射本地会话与消息ID，隐藏长ID和复杂细节。
- **异常处理与错误提示**：完整的错误检测、消息校验、异常处理和用户提示。

本系统连接**低功耗嵌入式硬件（Arduino）**与**AI云服务（Coze）**，实现跨平台的数据交互、消息管理、AI问答和消息转语音等多种高级功能。系统由**嵌入式固件**、**高效串口通讯协议**、**上位机C++/Python混合服务（cubeCom）**、**AI服务适配器**等模块组成。



```
[Arduino] <----> [串口协议/消息队列] <----> [cubeCom(pybind11 C++扩展)] <----> [Python AI服务] <----> [Coze API]
```

---

## 2. 主要技术模块详解

### 2.1 串口通信协议

#### 2.1.1 帧格式

采用定长前缀、起始字节、长度、数据、校验和的帧协议，设计防止帧丢失与数据错乱：

- **前缀（7字节）**：`0xAA` × 7，标志消息起始，抗干扰。
- **起始字节（1字节）**：`0xAB`，严格同步起始。
- **数据长度（2字节，大端）**：消息体长度，防溢出。
- **数据（N字节）**： 8bit 字节流。
- **校验和（2字节，大端）**：所有数据字节累加，强校验，抵御串口干扰。

#### 2.1.2 解析状态机

- 分为`s_prefix`、`s_start_b`、`s_len`、`s_data`、`s_check_sum`多个状态。
- 完整流式解析，任何异常立即复位，严格计数，错误包自动丢弃并计数。
- 支持单包最大512字节（`DATA_BUF_SIZE`），大包直接丢弃保护。
- 校验和不一致直接丢弃包，防止上层业务误处理。

#### 2.1.3 阻塞与异步

- **接收侧**采用异步事件驱动（`serialEvent`/后台线程），持续轮询读取数据，推入本地循环队列。
- **发送侧**同步操作，保证包完整性。

#### 2.1.4 循环队列实现

- 采用静态数组+`head/tail`指针的**环形队列**管理，最大队列长度`QUEUE_SIZE`，避免内存碎片和锁争用。
- **溢出自动丢弃最旧数据**，设计防止阻塞。
- 操作完全线程安全。

---

### 2.2 消息分发与队列机制

#### 2.2.1 上位机队列与锁

- 上位机Python服务维护**独立输入队列**，通过`mutex`加锁实现线程安全。
- 串口后台线程不断读取消息推入队列，主线程轮询取出处理。
- **完全无阻塞**：即使高并发或数据突发也不会卡死主循环。

#### 2.2.2 命令分发（Dispatcher）

- 接收消息后按照首行命令（如`CREATE_SESSION`、`ASK_AGENT`等）路由到对应处理函数。
- 参数解析基于`\n`分隔，协议简明，无需复杂正则或状态机。
- 未知指令直接返回`-1`

---

### 2.3 Coze API 交互与ID映射

#### 2.3.1 会话ID与消息ID本地映射

- Coze会话和消息ID均为长字符串，为兼容Arduino只支持int16，Python侧**生成递增int16作为映射ID**。
- 本地维护`session_map`、`message_map`、`session_recent_message`等字典完成映射。
- **保证每个会话/消息唯一可查，嵌入式端无需关心后端复杂ID，仅用短ID透明交互。**


---

### 2.5 协议/指令规范

#### 2.5.1 消息命令规范

每条命令均为大写命令名称+若干参数，参数严格按顺序排列，所有数据均不含`\n`，易于解析。

- **CREATE_SESSION**
- **CLEAR_SESSION_CONTEXT**\n会话ID
- **ASK_AGENT**\nagent_id\nsession_id\nprompt
- **GET_RECENT_MESSAGE**\n会话ID
- **MESSAGE_HAVE**\n消息ID\n关键词
- **MESSAGE_TO_SPEECH**\n消息ID
- **SHOW_MESSAGE**\n消息ID
- **SHOW_ALERT**\n内容

#### 2.5.2 校验和计算

- **串口底层**：对每条数据段累加和，采用int16大端格式，强制一致性校验。

---

### 2.6 错误处理与健壮性

- 所有链路（串口收发/消息解析/队列/API）均实现**异常捕获、超时保护、日志输出、错误码返回**。
- 任何失败均反馈`-1`，并设定最近的失败消息，便于嵌入式端判断与恢复。
- 队列溢出、串口溢出、数据错帧全部自动丢弃并计数。

---

### 2.7 C++ 到 Python 扩展


1. **C++模块编写**
   - `lib.cpp`/`Talk.cpp`实现了底层串口收发、队列、锁等所有IO相关功能，暴露C++原生API：`init`, `close`, `send`, `receive`, `empty`等。
   - 用标准C++与POSIX串口API实现，确保高效且跨平台。

2. **pybind11绑定**
   - 通过`pybind11`的`PYBIND11_MODULE`宏，导出模块名`cubeCom`，自动将C++函数映射为Python可调用接口。

3. **Python端直接调用**
   - 在Python代码（如`serv.py`）中，直接`import cubeCom`即可使用：
     ```python
     import cubeCom
     cubeCom.init("/dev/tty.usbmodemxxxx")
     cubeCom.send("xxx")
     msg = cubeCom.receive()
     ```
   - 所有串口读写、队列操作均在C++侧完成。






